// SPDX-License-Identifier: MIT OR Apache-2.0
pragma solidity 0.8.28;

import "./VaultBridgeToken.sol";
import {IVaultBridgeTokenInitializer} from "./etc/IVaultBridgeTokenInitializer.sol";

/// @title Vault Bridge Token
/// @notice A vbToken is an ERC-20 token, ERC-4626 vault, and LxLy Bridge extension, enabling deposits and bridging of select assets, such as WBTC, WETH, USDC, USDT, and DAI, while producing yield.
/// @dev A base contract used to create vault bridge tokens.
/// @dev In order to not drive the complexity of the STB system up, vbToken MUST NOT have transfer, deposit, or withdrawal fees. The underlying token on Layer X, and the underlying token and Custom Token on Layer Ys MAY have transfer fees. The yield vault SHOULD NOT have deposit and/or withdrawal fees. The price of yield vault's shares MUST NOT decrease (e.g., due to bad debt realization).
/// @dev It is expected that generated yield will offset any costs incurred when transferring the underlying token to and from the yield vault, or depositing to and withdrawing from the yield vault for the purpose of generating yield or rebalancing reserve.
contract VaultBridgeTokenInitializer is VaultBridgeToken, IVaultBridgeTokenInitializer {
    // Libraries.
    using SafeERC20 for IERC20;

    /// @dev @note (ATTENTION) `decimals` will match the underlying token. Defaults to 18 decimals if the underlying token reverts.
    /// @param minimumReservePercentage_ 1e18 is 100%.
    /// @param yieldVault_ An external, ERC-4246 compatible vault into which the underlying token is deposited to generate yield.
    /// @param yieldRecipient_ The address that receives yield generated by the yield vault. The owner collects generated yield, while the yield recipient receives it.
    /// @param nativeConverters_ The initial Native Converter on Layer Ys for this vbToken. One Layer Y cannot have more than one Native Converter.
    function __VaultBackedTokenInit_init(
        address owner_,
        string calldata name_,
        string calldata symbol_,
        address underlyingToken_,
        uint256 minimumReservePercentage_,
        address yieldVault_,
        address yieldRecipient_,
        address lxlyBridge_,
        NativeConverterInfo[] calldata nativeConverters_,
        uint256 minimumYieldVaultDeposit_,
        address transferFeeUtil_
    ) external {
        VaultBridgeTokenStorage storage $ = _getVaultBridgeTokenStorage();
        // Check the inputs.
        require(owner_ != address(0), InvalidOwner());
        require(bytes(name_).length > 0, InvalidName());
        require(bytes(symbol_).length > 0, InvalidSymbol());
        require(underlyingToken_ != address(0), InvalidUnderlyingToken());
        require(minimumReservePercentage_ <= 1e18, InvalidMinimumReservePercentage());
        require(yieldVault_ != address(0), InvalidYieldVault());
        require(yieldRecipient_ != address(0), InvalidYieldRecipient());
        require(lxlyBridge_ != address(0), InvalidLxLyBridge());

        // Initialize the inherited contracts.
        __ERC20_init(name_, symbol_);
        __ERC20Permit_init(name_);
        __AccessControl_init();
        __Pausable_init();
        __ReentrancyGuard_init();

        // Initialize the storage.
        $.underlyingToken = IERC20(underlyingToken_);
        try IERC20Metadata(underlyingToken_).decimals() returns (uint8 decimals_) {
            $.decimals = decimals_;
        } catch {
            // Default to 18 decimals.
            $.decimals = 18;
        }
        $.minimumReservePercentage = minimumReservePercentage_;
        $.yieldVault = IERC4626(yieldVault_);
        $.yieldRecipient = yieldRecipient_;
        $.lxlyId = ILxLyBridge(lxlyBridge_).networkID();
        $.lxlyBridge = ILxLyBridge(lxlyBridge_);
        for (uint256 i; i < nativeConverters_.length; ++i) {
            // Check the input.
            require(nativeConverters_[i].layerYLxlyId != $.lxlyId, InvalidNativeConverters());

            // Set Native Converter.
            $.nativeConverters[nativeConverters_[i].layerYLxlyId] = nativeConverters_[i].nativeConverter;
        }
        $.minimumYieldVaultDeposit = minimumYieldVaultDeposit_;
        $.transferFeeUtil = transferFeeUtil_;

        // Roles
        _grantRole(DEFAULT_ADMIN_ROLE, owner_);
        _grantRole(PAUSER_ROLE, owner_);
        _grantRole(REBALANCER_ROLE, owner_);
        _grantRole(YIELD_COLLECTOR_ROLE, owner_);

        // Approve the yield vault and LxLy Bridge.
        IERC20(underlyingToken_).forceApprove(yieldVault_, type(uint256).max);
        _approve(address(this), address(lxlyBridge_), type(uint256).max);
    }

    // Overwrite for safety
    function __VaultBridgeToken_init(
        address owner_,
        string calldata name_,
        string calldata symbol_,
        address underlyingToken_,
        uint256 minimumReservePercentage_,
        address yieldVault_,
        address yieldRecipient_,
        address lxlyBridge_,
        NativeConverterInfo[] calldata nativeConverters_,
        uint256 minimumYieldVaultDeposit_,
        address transferFeeUtil_,
        address initializer_
    ) internal override {}

    // Overwrite to save space

    // Overwrite because we have to
    function version() external pure override returns (string memory) {}

    function _assetsAfterTransferFee(uint256 assetsBeforeTransferFee)
        internal
        view
        virtual
        override
        returns (uint256)
    {}

    function _assetsBeforeTransferFee(uint256 minimumAssetsAfterTransferFee)
        internal
        view
        virtual
        override
        returns (uint256)
    {}
}
